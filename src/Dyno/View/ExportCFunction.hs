{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE RankNTypes #-}

module Dyno.View.ExportCFunction
       ( CExportOptions(..)
       , exportCFunction
       , exportCFunction'
       ) where

import Data.Char ( toUpper )
import Data.Maybe ( fromMaybe )
import Text.Printf ( printf )

import Accessors ( Lookup )
import Casadi.Function ( generateCode )
import Dyno.Vectorize ( Vectorize, fill )

import Dyno.View.ExportCStruct
import Dyno.View.Fun
import Dyno.View.JV ( JV, catJV', splitJV' )
import Dyno.View.View ( J )

data CExportOptions =
  CExportOptions
  { generateMain :: Bool
  , exportName :: String
  , headerOverride :: Maybe String -- ^ source will #include a difference file
  }

exportCFunction ::
  forall f g fun
  . (Vectorize f, Vectorize g, Lookup (f Double), Lookup (g Double), FunClass fun)
  => fun (J (JV f)) (J (JV g)) -> CExportOptions -> (String, String)
exportCFunction fun options = (source, header)
  where
    ((fname, gname), typedefs) = runCStructExporter $ do
      fname' <- putTypedef (fill 0 :: f Double)
      gname' <- putTypedef (fill 0 :: g Double)
      return (fname', gname')

    funName = exportName options
    header =
      unlines
      [ printf "#ifndef %s_H_" (map toUpper funName)
      , printf "#define %s_H_" (map toUpper funName)
      , ""
      , "/* This wrapper was automatically generated by dynobud. */"
      , ""
      , typedefs
      , ""
      , "#ifdef __cplusplus"
      , "extern \"C\" {"
      , "#endif"
      , ""
      , printf "  void %s(const %s* input, %s* output);" funName fname gname
      , ""
      , "#ifdef __cplusplus"
      , "extern \"C\" }"
      , "#endif"
      , ""
      , printf "#endif // %s_H_" (map toUpper funName)
      ]

    source =
      unlines
      [ generateCode (unFun (toFun fun)) (generateMain options)
      , ""
      , "/* The following wrapper was automaticaly generated by dynobud. */"
      , ""
      , printf "#include \"%s\"" (fromMaybe (funName ++ ".h") (headerOverride options))
      , ""
      , printf "void %s(const %s* input, %s* output) {" funName fname gname
      , "  evaluate((const double *)input, (double *)output);"
      , "}"
      ]

-- convenience function which wraps a Floating type
exportCFunction' ::
  forall f g
  . (Vectorize f, Vectorize g, Lookup (f Double), Lookup (g Double))
  => (forall a . Floating a => f a -> g a) -> CExportOptions -> IO (String, String)
exportCFunction' userFun opts = do
  sxfun <- toSXFun "userCodegenFun" (catJV' . userFun . splitJV')
  return (exportCFunction sxfun opts)
